/***************************************************************************************************
****************************************************************************************************
****************************************************************************************************

Project : Smart Fan Timer

Revision: 20160312 (initial)

Authors : Vlady

Company : Home, Sweet Home

Chip type: ATMega328P (32-lead TQFP)

AVR Core Clock frequency: внутренний RC-генератор 8 MHz

Fuse Bits:
	ОТКЛЮЧАЕМ внутренний делитель на 8
	Ставим BODLEVEL на Vcc = 4,3V
	Остальное as shipped
		0xE2 - LOW
		0xD9 - HIGH
		0xFC - EXTENDED

Comments:

****************************************************************************************************
***** ОБЩЕЕ ОПИСАНИЕ *****
****************************************************************************************************

Это двухканальный "умный" таймер для двух компьютерных (12-вольтовых) вентиляторов с
встроенным мониторингом их исправности для применения в системе вытяжки на кухне, в
гараже и т.п.

Предназначен для 
- включения вентиляторов на заданный вручную период времени,
- ручного управления скоростью вращения,
- автоматического контроля исправности вентиляторов с индикацией светодиодами и бипером.

Допустимое количество управляемых и контролируемых каналов/вентиляторов - от 1 до 2. 


ОРГАНЫ УПРАВЛЕНИЯ
- три кнопки управления.
- три потенциометра.

Кнопки RUN, STOP и SELECTOR наружные, легкодоступные для пользователя. 
Кнопка RUN при коротком нажатии включает оба вентилятора на определённый
промежуток времени. При работающих вентиляторах повторное короткое нажатие на RUN в
любой момент повторно запускает таймер с начала.
Кнопка STOP в любой момент времени выключает оба вентилятора (по сути - обнуляет время таймера).
Кнопка SELECTOR (только при запущенном RUN) позволяет выбрать для работы конкретный
вентилятор или оба сразу.
Тут хорошо бы сделать, чтобы нажатие SELECTOR "пробуждало" индикаторные
светодиоды вентиляторов, позволяя выбрать нужный вентилятор ещё до запуска RUN, а если RUN после
выбора не нажали, то через 10 сек светодиоды тухли, а выбор "работающих/неработающих"
вентиляторов оставался "запомненным" (для того, чтобы ВЫ выбрали заранее, какой вентилятор будет
работать, а какой нет, а потом жена только включала (RUN) и выключала (STOP) ваш выбор).

Два потенциометра управляют скоростью вращения вентиляторов (регулируют
параметры FB преобразователей DC-DC), а третий потенциометр "Время" устанавливает выдержку
таймера (через АЦП микроконтроллера).


Включение вентиляторов осуществляется подачей питания (по входам ENABLE
преобразователей DC-DC), а скорость вращения вентиляторов управляется величиной
напряжения питания (цепями FB преобразователей DC-DC).
Для отслеживания исправности вентиляторов используются мониторинг потребляемого
вентиляторами тока и встроенные в вентиляторы таходатчики.

****************************************************************************************************
****************************************************************************************************
***************************************************************************************************/



/****************************************************************************************************
*
***** Настройки и подключение библиотек/модулей *****
*
****************************************************************************************************/

#include <avr/io.h>
// #include <avr/eeprom.h>
#include <avr/interrupt.h>
#include <stdint.h>
// #include <avr/wdt.h>
// #include <avr/sleep.h>
// #include <util/atomic.h>

#ifndef F_CPU
#define F_CPU	8000000ul	// МК работает с внутренней тактировкой 8 МГц
#endif

#include "commons.h"
#include "gtimer.h"
#include "buttons.h"
#include "leds.h"
#include "adc.h"
#include "executive.h"




/****************************************************************************************************
*
***** ГЛАВНАЯ ФУНКЦИЯ *****
*
****************************************************************************************************/

int main (void) {

// конфигурируем системные часы

	TIMER2_SysTime_Init();

// конфигурируем порты

	LEDs_Init();
	BUTTONS_Init();
	
// конфигурируем переменные



// стартуем вспомогательные сервисы и инициализируем состояния

	GTimer_Init();				// таймеры

// Подготовка закончена. "Поехали!" (c) Ю. А. Гагарин

	ENABLE_INTERRUPT();


// ГЛАВНЫЙ ЦИКЛ
	for(;;)	{

		if (GTimer_Exp(GTIMER_SYS_LED)) {	// проверка истечения таймера SysLED
			SysLED_Blink(); 				// и вход в автомат мигания SysLED
		}
		
		if (GTimer_Exp(GTIMER_BUTTONS)) {	// проверка истечения таймера опроса кнопок
			BUTTONS_Debrief();				// опрашиваем кнопки
		}
		
		ADC_Controller();					// запуск функции управления АЦПшкой

		Executive();						// все приготовления сделаны; теперь
											// приступаем к выполнению полезной работы
		
		if (SysTick) SysTime_Handler();		// системные часы
	}
	return 0;
}



/****************************************************************************************************
*
***** Обработчики прерываний *****
*
****************************************************************************************************/

/**************************************************************************
*	Function name :	ISR (TIMER2_OVF_vect)
*	Returns :		нет
*	Parameters :	динамически меняющихся нет,
*					статические определяются функцией Init_TIMER2_systime()
*	Purpose :		Обработчик прерывания системных часов TIMER2
****************************************************************************/

ISR (TIMER2_OVF_vect) {
	TCNT2 = 178;			// реинициализация счетчика TIMER2 под SYS_TICK_PERIOD 
	SysTick = 1;			// поднимаем флаг систика, опустим его в SysTime_Handler()
	return;
}



/**************************************************************************
*	Function name :	ISR (ADC_vect)
*	Returns :		нет
*	Parameters :	динамически меняющихся нет
*	Purpose :		Обработчик прерывания АЦП
****************************************************************************/

ISR (ADC_vect) {
	ADC_Value[ADC_State] = ADCH;	// сбрасываем оцифрованное значение в соответствующий буфер	
	ADC_Latch = 1;					// ставим флаг "АЦП закончил обработку входа"
	return;
}
